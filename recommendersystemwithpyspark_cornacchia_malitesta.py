# -*- coding: utf-8 -*-
"""RecommenderSystemWithPySpark_Cornacchia_Malitesta.ipynb

Automatically generated by Colaboratory.

Original file is located at
https://colab.research.google.com/drive/1o18KCbRiM3xtNwtbCYw-_pdM47vdqzyO

####commenti
"""


import pyspark
from pyspark.sql import SparkSession
spark=SparkSession.builder.appName('rc').getOrCreate()

file_location = "data/movie_ratings_df.csv"
file_type = "csv"
infer_schema = "false"
first_row_is_header = "true"
delimiter = ","

df = spark.read.format(file_type) \
.option("inferSchema", infer_schema) \
.option("header", first_row_is_header) \
.option("sep", delimiter) \
.load(file_location)

df.show(5,False)

#x = indexed.groupBy('userId').count()
#x.filter(x['count']>30).show()

print((df.count(), len(df.columns)))

df.printSchema()

from pyspark.sql.functions import *
df.orderBy(rand()).show(10,False)

df.groupBy('userId').count().orderBy('count',ascending=False).show(10,False)

df.groupBy('userId').count().orderBy('count',ascending=True).show(10,False)

df.groupBy('title').count().orderBy('count',ascending=False).show(10,False)

from pyspark.ml.feature import StringIndexer,IndexToString
from pyspark.sql.types import DoubleType
df = df.withColumn("userId", df.userId.cast(DoubleType()))
df = df.withColumn("rating", df.rating.cast(DoubleType()))
stringIndexer = StringIndexer(inputCol="title", outputCol="title_new")

model = stringIndexer.fit(df)
indexed = model.transform(df)

indexed.show(10)

indexed.groupBy('title_new').count().orderBy('count',ascending=False).show(10,False)

train,test=indexed.randomSplit([0.75,0.25])

train.count()

test.count()

train.show(5,False)

from pyspark.ml.recommendation import ALS
rec=ALS(maxIter=10,regParam=0.01,userCol='userId',itemCol='title_new',
ratingCol='rating',nonnegative=True,coldStartStrategy="drop")

rec_model=rec.fit(train)

predicted_ratings=rec_model.transform(test)

predicted_ratings.printSchema()

predicted_ratings.orderBy(rand()).show(10)

from pyspark.ml.evaluation import RegressionEvaluator
evaluator=RegressionEvaluator(metricName='rmse',predictionCol=
'prediction',labelCol='rating')
rmse=evaluator.evaluate(predicted_ratings)

print(rmse)

unique_movies=indexed.select('title_new').distinct()
unique_movies.count()

a = unique_movies.alias('a')
user_id=85.0
watched_movies=indexed.filter(indexed['userId'] == user_id).select('title_new').distinct()

watched_movies.count()

b=watched_movies.alias('b')
total_movies = a.join(b, a.title_new == b.title_new,how='left')
total_movies.show(10,False)

remaining_movies=total_movies.where(col("b.title_new").isNull()).select(a.title_new).distinct()
remaining_movies.count()

remaining_movies=remaining_movies.withColumn("userId",lit(int(user_id)))
remaining_movies.show(10,False)

recommendations=rec_model.transform(remaining_movies).orderBy('prediction',ascending=False)

recommendations.show(5,False)

movie_title = IndexToString(inputCol="title_new",
outputCol="title",labels=model.labels)
final_recommendations=movie_title.transform(recommendations)
final_recommendations.show(10,False)

#create function to recommend top 'n' movies to any particular user
def top_movies(user_id,n):
  """
  This function returns the top 'n' movies that user has not seen yet but
  might like
  """
  #assigning alias name 'a' to unique movies df
  a = unique_movies.alias('a')
  #creating another dataframe which contains already watched movie by active user
  watched_movies=indexed.filter(indexed['userId'] == user_id).select('title_new')
  #assigning alias name 'b' to watched movies df
  b=watched_movies.alias('b')
  #joining both tables on left join
  total_movies = a.join(b, a.title_new == b.title_new,how='left')
  #selecting movies which active user is yet to rate or watch
  remaining_movies=total_movies.where(col("b.title_new").isNull()).select(a.title_new).distinct()
  #adding new column of user_Id of active useer to remaining movies df
  remaining_movies=remaining_movies.withColumn("userId",lit(int(user_id)))
  #making recommendations using ALS recommender model and selecting only top 'n' movies
  recommendations=rec_model.transform(remaining_movies).orderBy('prediction',ascending=False).limit(n)
  #adding columns of movie titles in recommendations
  movie_title = IndexToString(inputCol="title_new",
  outputCol="title",labels=model.labels)
  final_recommendations=movie_title.transform(recommendations)
  output=final_recommendations.select('userId','title_new','title')
  #return the recommendations to active user
  return output.show(n,False)

top_movies(67.0,10)